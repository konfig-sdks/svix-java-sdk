/*
 * Svix API
 * Welcome to the Svix API documentation!  Useful links: [Homepage](https://www.svix.com) | [Support email](mailto:support+docs@svix.com) | [Blog](https://www.svix.com/blog/) | [Slack Community](https://www.svix.com/slack/)  # Introduction  This is the reference documentation and schemas for the [Svix webhook service](https://www.svix.com) API. For tutorials and other documentation please refer to [the documentation](https://docs.svix.com).  ## Main concepts  In Svix you have four important entities you will be interacting with:  - `messages`: these are the webhooks being sent. They can have contents and a few other properties. - `application`: this is where `messages` are sent to. Usually you want to create one application for each user on your platform. - `endpoint`: endpoints are the URLs messages will be sent to. Each application can have multiple `endpoints` and each message sent to that application will be sent to all of them (unless they are not subscribed to the sent event type). - `event-type`: event types are identifiers denoting the type of the message being sent. Event types are primarily used to decide which events are sent to which endpoint.   ## Authentication  Get your authentication token (`AUTH_TOKEN`) from the [Svix dashboard](https://dashboard.svix.com) and use it as part of the `Authorization` header as such: `Authorization: Bearer ${AUTH_TOKEN}`. For more information on authentication, please refer to the [authentication token docs](https://docs.svix.com/api-keys).     ## Code samples  The code samples assume you already have the respective libraries installed and you know how to use them. For the latest information on how to do that, please refer to [the documentation](https://docs.svix.com/).   ## Idempotency  Svix supports [idempotency](https://en.wikipedia.org/wiki/Idempotence) for safely retrying requests without accidentally performing the same operation twice. This is useful when an API call is disrupted in transit and you do not receive a response.  To perform an idempotent request, pass the idempotency key in the `Idempotency-Key` header to the request. The idempotency key should be a unique value generated by the client. You can create the key in however way you like, though we suggest using UUID v4, or any other string with enough entropy to avoid collisions.  Svix's idempotency works by saving the resulting status code and body of the first request made for any given idempotency key for any successful request. Subsequent requests with the same key return the same result for a period of up to 12 hours.  Please note that idempotency is only supported for `POST` requests.   ## Cross-Origin Resource Sharing  This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/). And that allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site. 
 *
 * The version of the OpenAPI document: 1.21.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ApplicationIn;
import com.konfigthis.client.model.ListResponseMessageOut;
import com.konfigthis.client.model.MessageIn;
import com.konfigthis.client.model.MessageOut;
import java.time.OffsetDateTime;
import java.util.Set;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class MessageApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessageApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public MessageApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createNewMsgCall(String appId, MessageIn messageIn, Boolean withContent, String idempotencyKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = messageIn;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (withContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with_content", withContent));
        }

        if (idempotencyKey != null) {
            localVarHeaderParams.put("idempotency-key", localVarApiClient.parameterToString(idempotencyKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createNewMsgValidateBeforeCall(String appId, MessageIn messageIn, Boolean withContent, String idempotencyKey, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling createNewMsg(Async)");
        }

        // verify the required parameter 'messageIn' is set
        if (messageIn == null) {
            throw new ApiException("Missing the required parameter 'messageIn' when calling createNewMsg(Async)");
        }

        return createNewMsgCall(appId, messageIn, withContent, idempotencyKey, _callback);

    }


    private ApiResponse<MessageOut> createNewMsgWithHttpInfo(String appId, MessageIn messageIn, Boolean withContent, String idempotencyKey) throws ApiException {
        okhttp3.Call localVarCall = createNewMsgValidateBeforeCall(appId, messageIn, withContent, idempotencyKey, null);
        Type localVarReturnType = new TypeToken<MessageOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createNewMsgAsync(String appId, MessageIn messageIn, Boolean withContent, String idempotencyKey, final ApiCallback<MessageOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = createNewMsgValidateBeforeCall(appId, messageIn, withContent, idempotencyKey, _callback);
        Type localVarReturnType = new TypeToken<MessageOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateNewMsgRequestBuilder {
        private final String eventType;
        private final Object payload;
        private final String appId;
        private Set<String> tags;
        private String eventId;
        private Set<String> channels;
        private Long payloadRetentionPeriod;
        private ApplicationIn application;
        private Object transformationsParams;
        private Boolean withContent;
        private String idempotencyKey;

        private CreateNewMsgRequestBuilder(String eventType, Object payload, String appId) {
            this.eventType = eventType;
            this.payload = payload;
            this.appId = appId;
        }

        /**
         * Set tags
         * @param tags List of free-form tags that can be filtered by when listing messages (optional)
         * @return CreateNewMsgRequestBuilder
         */
        public CreateNewMsgRequestBuilder tags(Set<String> tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set eventId
         * @param eventId Optional unique identifier for the message (optional)
         * @return CreateNewMsgRequestBuilder
         */
        public CreateNewMsgRequestBuilder eventId(String eventId) {
            this.eventId = eventId;
            return this;
        }
        
        /**
         * Set channels
         * @param channels List of free-form identifiers that endpoints can filter by (optional)
         * @return CreateNewMsgRequestBuilder
         */
        public CreateNewMsgRequestBuilder channels(Set<String> channels) {
            this.channels = channels;
            return this;
        }
        
        /**
         * Set payloadRetentionPeriod
         * @param payloadRetentionPeriod  (optional, default to 90)
         * @return CreateNewMsgRequestBuilder
         */
        public CreateNewMsgRequestBuilder payloadRetentionPeriod(Long payloadRetentionPeriod) {
            this.payloadRetentionPeriod = payloadRetentionPeriod;
            return this;
        }
        
        /**
         * Set application
         * @param application  (optional)
         * @return CreateNewMsgRequestBuilder
         */
        public CreateNewMsgRequestBuilder application(ApplicationIn application) {
            this.application = application;
            return this;
        }
        
        /**
         * Set transformationsParams
         * @param transformationsParams Extra parameters to pass to Transformations (for future use) (optional)
         * @return CreateNewMsgRequestBuilder
         */
        public CreateNewMsgRequestBuilder transformationsParams(Object transformationsParams) {
            this.transformationsParams = transformationsParams;
            return this;
        }
        
        /**
         * Set withContent
         * @param withContent When &#x60;true&#x60; message payloads are included in the response (optional, default to true)
         * @return CreateNewMsgRequestBuilder
         */
        public CreateNewMsgRequestBuilder withContent(Boolean withContent) {
            this.withContent = withContent;
            return this;
        }
        
        /**
         * Set idempotencyKey
         * @param idempotencyKey The request&#39;s idempotency key (optional)
         * @return CreateNewMsgRequestBuilder
         */
        public CreateNewMsgRequestBuilder idempotencyKey(String idempotencyKey) {
            this.idempotencyKey = idempotencyKey;
            return this;
        }
        
        /**
         * Build call for createNewMsg
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            MessageIn messageIn = buildBodyParams();
            return createNewMsgCall(appId, messageIn, withContent, idempotencyKey, _callback);
        }

        private MessageIn buildBodyParams() {
            MessageIn messageIn = new MessageIn();
            messageIn.tags(this.tags);
            messageIn.eventId(this.eventId);
            messageIn.eventType(this.eventType);
            messageIn.payload(this.payload);
            messageIn.channels(this.channels);
            messageIn.payloadRetentionPeriod(this.payloadRetentionPeriod);
            messageIn.application(this.application);
            messageIn.transformationsParams(this.transformationsParams);
            return messageIn;
        }

        /**
         * Execute createNewMsg request
         * @return MessageOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public MessageOut execute() throws ApiException {
            MessageIn messageIn = buildBodyParams();
            ApiResponse<MessageOut> localVarResp = createNewMsgWithHttpInfo(appId, messageIn, withContent, idempotencyKey);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createNewMsg request with HTTP info returned
         * @return ApiResponse&lt;MessageOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MessageOut> executeWithHttpInfo() throws ApiException {
            MessageIn messageIn = buildBodyParams();
            return createNewMsgWithHttpInfo(appId, messageIn, withContent, idempotencyKey);
        }

        /**
         * Execute createNewMsg request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MessageOut> _callback) throws ApiException {
            MessageIn messageIn = buildBodyParams();
            return createNewMsgAsync(appId, messageIn, withContent, idempotencyKey, _callback);
        }
    }

    /**
     * Create Message
     * Creates a new message and dispatches it to all of the application&#39;s endpoints.  The &#x60;eventId&#x60; is an optional custom unique ID. It&#39;s verified to be unique only up to a day, after that no verification will be made. If a message with the same &#x60;eventId&#x60; already exists for any application in your environment, a 409 conflict error will be returned.  The &#x60;eventType&#x60; indicates the type and schema of the event. All messages of a certain &#x60;eventType&#x60; are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have &#x60;channels&#x60;, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don&#39;t imply a specific message content or schema.  The &#x60;payload&#x60; property is the webhook&#39;s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it&#39;s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
     * @param appId The app&#39;s ID or UID (required)
     * @param messageIn  (required)
     * @return CreateNewMsgRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public CreateNewMsgRequestBuilder createNewMsg(String eventType, Object payload, String appId) throws IllegalArgumentException {
        if (eventType == null) throw new IllegalArgumentException("\"eventType\" is required but got null");
            

        if (payload == null) throw new IllegalArgumentException("\"payload\" is required but got null");
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        return new CreateNewMsgRequestBuilder(eventType, payload, appId);
    }
    private okhttp3.Call deletePayloadCall(String appId, String msgId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg/{msg_id}/content"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deletePayloadValidateBeforeCall(String appId, String msgId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling deletePayload(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling deletePayload(Async)");
        }

        return deletePayloadCall(appId, msgId, _callback);

    }


    private ApiResponse<Void> deletePayloadWithHttpInfo(String appId, String msgId) throws ApiException {
        okhttp3.Call localVarCall = deletePayloadValidateBeforeCall(appId, msgId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deletePayloadAsync(String appId, String msgId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deletePayloadValidateBeforeCall(appId, msgId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeletePayloadRequestBuilder {
        private final String appId;
        private final String msgId;

        private DeletePayloadRequestBuilder(String appId, String msgId) {
            this.appId = appId;
            this.msgId = msgId;
        }

        /**
         * Build call for deletePayload
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deletePayloadCall(appId, msgId, _callback);
        }


        /**
         * Execute deletePayload request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deletePayloadWithHttpInfo(appId, msgId);
        }

        /**
         * Execute deletePayload request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deletePayloadWithHttpInfo(appId, msgId);
        }

        /**
         * Execute deletePayload request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deletePayloadAsync(appId, msgId, _callback);
        }
    }

    /**
     * Delete message payload
     * Delete the given message&#39;s payload. Useful in cases when a message was accidentally sent with sensitive content.  The message can&#39;t be replayed or resent once its payload has been deleted or expired.
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @return DeletePayloadRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
     </table>
     */
    public DeletePayloadRequestBuilder deletePayload(String appId, String msgId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        return new DeletePayloadRequestBuilder(appId, msgId);
    }
    private okhttp3.Call getByIdOrEventIdCall(String appId, String msgId, Boolean withContent, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg/{msg_id}"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (withContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with_content", withContent));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByIdOrEventIdValidateBeforeCall(String appId, String msgId, Boolean withContent, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling getByIdOrEventId(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling getByIdOrEventId(Async)");
        }

        return getByIdOrEventIdCall(appId, msgId, withContent, _callback);

    }


    private ApiResponse<MessageOut> getByIdOrEventIdWithHttpInfo(String appId, String msgId, Boolean withContent) throws ApiException {
        okhttp3.Call localVarCall = getByIdOrEventIdValidateBeforeCall(appId, msgId, withContent, null);
        Type localVarReturnType = new TypeToken<MessageOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByIdOrEventIdAsync(String appId, String msgId, Boolean withContent, final ApiCallback<MessageOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByIdOrEventIdValidateBeforeCall(appId, msgId, withContent, _callback);
        Type localVarReturnType = new TypeToken<MessageOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetByIdOrEventIdRequestBuilder {
        private final String appId;
        private final String msgId;
        private Boolean withContent;

        private GetByIdOrEventIdRequestBuilder(String appId, String msgId) {
            this.appId = appId;
            this.msgId = msgId;
        }

        /**
         * Set withContent
         * @param withContent When &#x60;true&#x60; message payloads are included in the response (optional, default to true)
         * @return GetByIdOrEventIdRequestBuilder
         */
        public GetByIdOrEventIdRequestBuilder withContent(Boolean withContent) {
            this.withContent = withContent;
            return this;
        }
        
        /**
         * Build call for getByIdOrEventId
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByIdOrEventIdCall(appId, msgId, withContent, _callback);
        }


        /**
         * Execute getByIdOrEventId request
         * @return MessageOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public MessageOut execute() throws ApiException {
            ApiResponse<MessageOut> localVarResp = getByIdOrEventIdWithHttpInfo(appId, msgId, withContent);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getByIdOrEventId request with HTTP info returned
         * @return ApiResponse&lt;MessageOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MessageOut> executeWithHttpInfo() throws ApiException {
            return getByIdOrEventIdWithHttpInfo(appId, msgId, withContent);
        }

        /**
         * Execute getByIdOrEventId request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MessageOut> _callback) throws ApiException {
            return getByIdOrEventIdAsync(appId, msgId, withContent, _callback);
        }
    }

    /**
     * Get Message
     * Get a message by its ID or eventID.
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @return GetByIdOrEventIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public GetByIdOrEventIdRequestBuilder getByIdOrEventId(String appId, String msgId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        return new GetByIdOrEventIdRequestBuilder(appId, msgId);
    }
    private okhttp3.Call listAllMessagesCall(String appId, Integer limit, String iterator, String channel, OffsetDateTime before, OffsetDateTime after, Boolean withContent, String tag, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (iterator != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("iterator", iterator));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (after != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("after", after));
        }

        if (withContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with_content", withContent));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (eventTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "event_types", eventTypes));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAllMessagesValidateBeforeCall(String appId, Integer limit, String iterator, String channel, OffsetDateTime before, OffsetDateTime after, Boolean withContent, String tag, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling listAllMessages(Async)");
        }

        return listAllMessagesCall(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes, _callback);

    }


    private ApiResponse<ListResponseMessageOut> listAllMessagesWithHttpInfo(String appId, Integer limit, String iterator, String channel, OffsetDateTime before, OffsetDateTime after, Boolean withContent, String tag, Set<String> eventTypes) throws ApiException {
        okhttp3.Call localVarCall = listAllMessagesValidateBeforeCall(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes, null);
        Type localVarReturnType = new TypeToken<ListResponseMessageOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAllMessagesAsync(String appId, Integer limit, String iterator, String channel, OffsetDateTime before, OffsetDateTime after, Boolean withContent, String tag, Set<String> eventTypes, final ApiCallback<ListResponseMessageOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = listAllMessagesValidateBeforeCall(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes, _callback);
        Type localVarReturnType = new TypeToken<ListResponseMessageOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListAllMessagesRequestBuilder {
        private final String appId;
        private Integer limit;
        private String iterator;
        private String channel;
        private OffsetDateTime before;
        private OffsetDateTime after;
        private Boolean withContent;
        private String tag;
        private Set<String> eventTypes;

        private ListAllMessagesRequestBuilder(String appId) {
            this.appId = appId;
        }

        /**
         * Set limit
         * @param limit Limit the number of returned items (optional)
         * @return ListAllMessagesRequestBuilder
         */
        public ListAllMessagesRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set iterator
         * @param iterator The iterator returned from a prior invocation (optional)
         * @return ListAllMessagesRequestBuilder
         */
        public ListAllMessagesRequestBuilder iterator(String iterator) {
            this.iterator = iterator;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Filter response based on the channel (optional)
         * @return ListAllMessagesRequestBuilder
         */
        public ListAllMessagesRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set before
         * @param before Only include items created before a certain date (optional)
         * @return ListAllMessagesRequestBuilder
         */
        public ListAllMessagesRequestBuilder before(OffsetDateTime before) {
            this.before = before;
            return this;
        }
        
        /**
         * Set after
         * @param after Only include items created after a certain date (optional)
         * @return ListAllMessagesRequestBuilder
         */
        public ListAllMessagesRequestBuilder after(OffsetDateTime after) {
            this.after = after;
            return this;
        }
        
        /**
         * Set withContent
         * @param withContent When &#x60;true&#x60; message payloads are included in the response (optional, default to true)
         * @return ListAllMessagesRequestBuilder
         */
        public ListAllMessagesRequestBuilder withContent(Boolean withContent) {
            this.withContent = withContent;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter messages matching the provided tag (optional)
         * @return ListAllMessagesRequestBuilder
         */
        public ListAllMessagesRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set eventTypes
         * @param eventTypes Filter response based on the event type (optional)
         * @return ListAllMessagesRequestBuilder
         */
        public ListAllMessagesRequestBuilder eventTypes(Set<String> eventTypes) {
            this.eventTypes = eventTypes;
            return this;
        }
        
        /**
         * Build call for listAllMessages
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listAllMessagesCall(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes, _callback);
        }


        /**
         * Execute listAllMessages request
         * @return ListResponseMessageOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ListResponseMessageOut execute() throws ApiException {
            ApiResponse<ListResponseMessageOut> localVarResp = listAllMessagesWithHttpInfo(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listAllMessages request with HTTP info returned
         * @return ApiResponse&lt;ListResponseMessageOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListResponseMessageOut> executeWithHttpInfo() throws ApiException {
            return listAllMessagesWithHttpInfo(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes);
        }

        /**
         * Execute listAllMessages request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListResponseMessageOut> _callback) throws ApiException {
            return listAllMessagesAsync(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes, _callback);
        }
    }

    /**
     * List Messages
     * List all of the application&#39;s messages.  The &#x60;before&#x60; and &#x60;after&#x60; parameters let you filter all items created before or after a certain date. These can be used alongside an iterator to paginate over results within a certain window.  Note that by default this endpoint is limited to retrieving 90 days&#39; worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the &#x60;before&#x60; or &#x60;after&#x60; parameter as appropriate. 
     * @param appId The app&#39;s ID or UID (required)
     * @return ListAllMessagesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ListAllMessagesRequestBuilder listAllMessages(String appId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        return new ListAllMessagesRequestBuilder(appId);
    }
}
