/*
 * Svix API
 * Welcome to the Svix API documentation!  Useful links: [Homepage](https://www.svix.com) | [Support email](mailto:support+docs@svix.com) | [Blog](https://www.svix.com/blog/) | [Slack Community](https://www.svix.com/slack/)  # Introduction  This is the reference documentation and schemas for the [Svix webhook service](https://www.svix.com) API. For tutorials and other documentation please refer to [the documentation](https://docs.svix.com).  ## Main concepts  In Svix you have four important entities you will be interacting with:  - `messages`: these are the webhooks being sent. They can have contents and a few other properties. - `application`: this is where `messages` are sent to. Usually you want to create one application for each user on your platform. - `endpoint`: endpoints are the URLs messages will be sent to. Each application can have multiple `endpoints` and each message sent to that application will be sent to all of them (unless they are not subscribed to the sent event type). - `event-type`: event types are identifiers denoting the type of the message being sent. Event types are primarily used to decide which events are sent to which endpoint.   ## Authentication  Get your authentication token (`AUTH_TOKEN`) from the [Svix dashboard](https://dashboard.svix.com) and use it as part of the `Authorization` header as such: `Authorization: Bearer ${AUTH_TOKEN}`. For more information on authentication, please refer to the [authentication token docs](https://docs.svix.com/api-keys).     ## Code samples  The code samples assume you already have the respective libraries installed and you know how to use them. For the latest information on how to do that, please refer to [the documentation](https://docs.svix.com/).   ## Idempotency  Svix supports [idempotency](https://en.wikipedia.org/wiki/Idempotence) for safely retrying requests without accidentally performing the same operation twice. This is useful when an API call is disrupted in transit and you do not receive a response.  To perform an idempotent request, pass the idempotency key in the `Idempotency-Key` header to the request. The idempotency key should be a unique value generated by the client. You can create the key in however way you like, though we suggest using UUID v4, or any other string with enough entropy to avoid collisions.  Svix's idempotency works by saving the resulting status code and body of the first request made for any given idempotency key for any successful request. Subsequent requests with the same key return the same result for a period of up to 12 hours.  Please note that idempotency is only supported for `POST` requests.   ## Cross-Origin Resource Sharing  This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/). And that allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site. 
 *
 * The version of the OpenAPI document: 1.21.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ListResponseEndpointMessageOut;
import com.konfigthis.client.model.ListResponseMessageAttemptEndpointOut;
import com.konfigthis.client.model.ListResponseMessageAttemptOut;
import com.konfigthis.client.model.ListResponseMessageEndpointOut;
import com.konfigthis.client.model.MessageAttemptOut;
import com.konfigthis.client.model.MessageStatus;
import java.time.OffsetDateTime;
import java.util.Set;
import com.konfigthis.client.model.StatusCodeClass;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class MessageAttemptApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessageAttemptApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public MessageAttemptApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call deleteResponseBodyCall(String appId, String msgId, String attemptId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/content"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()))
            .replace("{" + "attempt_id" + "}", localVarApiClient.escapeString(attemptId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteResponseBodyValidateBeforeCall(String appId, String msgId, String attemptId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling deleteResponseBody(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling deleteResponseBody(Async)");
        }

        // verify the required parameter 'attemptId' is set
        if (attemptId == null) {
            throw new ApiException("Missing the required parameter 'attemptId' when calling deleteResponseBody(Async)");
        }

        return deleteResponseBodyCall(appId, msgId, attemptId, _callback);

    }


    private ApiResponse<Void> deleteResponseBodyWithHttpInfo(String appId, String msgId, String attemptId) throws ApiException {
        okhttp3.Call localVarCall = deleteResponseBodyValidateBeforeCall(appId, msgId, attemptId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteResponseBodyAsync(String appId, String msgId, String attemptId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteResponseBodyValidateBeforeCall(appId, msgId, attemptId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteResponseBodyRequestBuilder {
        private final String appId;
        private final String msgId;
        private final String attemptId;

        private DeleteResponseBodyRequestBuilder(String appId, String msgId, String attemptId) {
            this.appId = appId;
            this.msgId = msgId;
            this.attemptId = attemptId;
        }

        /**
         * Build call for deleteResponseBody
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteResponseBodyCall(appId, msgId, attemptId, _callback);
        }


        /**
         * Execute deleteResponseBody request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteResponseBodyWithHttpInfo(appId, msgId, attemptId);
        }

        /**
         * Execute deleteResponseBody request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteResponseBodyWithHttpInfo(appId, msgId, attemptId);
        }

        /**
         * Execute deleteResponseBody request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteResponseBodyAsync(appId, msgId, attemptId, _callback);
        }
    }

    /**
     * Delete attempt response body
     * Deletes the given attempt&#39;s response body. Useful when an endpoint accidentally returned sensitive content.
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @param attemptId The attempt&#39;s ID (required)
     * @return DeleteResponseBodyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
     </table>
     */
    public DeleteResponseBodyRequestBuilder deleteResponseBody(String appId, String msgId, String attemptId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        if (attemptId == null) throw new IllegalArgumentException("\"attemptId\" is required but got null");
            

        return new DeleteResponseBodyRequestBuilder(appId, msgId, attemptId);
    }
    private okhttp3.Call getByAttemptCall(String appId, String msgId, String attemptId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()))
            .replace("{" + "attempt_id" + "}", localVarApiClient.escapeString(attemptId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByAttemptValidateBeforeCall(String appId, String msgId, String attemptId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling getByAttempt(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling getByAttempt(Async)");
        }

        // verify the required parameter 'attemptId' is set
        if (attemptId == null) {
            throw new ApiException("Missing the required parameter 'attemptId' when calling getByAttempt(Async)");
        }

        return getByAttemptCall(appId, msgId, attemptId, _callback);

    }


    private ApiResponse<MessageAttemptOut> getByAttemptWithHttpInfo(String appId, String msgId, String attemptId) throws ApiException {
        okhttp3.Call localVarCall = getByAttemptValidateBeforeCall(appId, msgId, attemptId, null);
        Type localVarReturnType = new TypeToken<MessageAttemptOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByAttemptAsync(String appId, String msgId, String attemptId, final ApiCallback<MessageAttemptOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByAttemptValidateBeforeCall(appId, msgId, attemptId, _callback);
        Type localVarReturnType = new TypeToken<MessageAttemptOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetByAttemptRequestBuilder {
        private final String appId;
        private final String msgId;
        private final String attemptId;

        private GetByAttemptRequestBuilder(String appId, String msgId, String attemptId) {
            this.appId = appId;
            this.msgId = msgId;
            this.attemptId = attemptId;
        }

        /**
         * Build call for getByAttempt
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByAttemptCall(appId, msgId, attemptId, _callback);
        }


        /**
         * Execute getByAttempt request
         * @return MessageAttemptOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public MessageAttemptOut execute() throws ApiException {
            ApiResponse<MessageAttemptOut> localVarResp = getByAttemptWithHttpInfo(appId, msgId, attemptId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getByAttempt request with HTTP info returned
         * @return ApiResponse&lt;MessageAttemptOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MessageAttemptOut> executeWithHttpInfo() throws ApiException {
            return getByAttemptWithHttpInfo(appId, msgId, attemptId);
        }

        /**
         * Execute getByAttempt request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MessageAttemptOut> _callback) throws ApiException {
            return getByAttemptAsync(appId, msgId, attemptId, _callback);
        }
    }

    /**
     * Get Attempt
     * &#x60;msg_id&#x60;: Use a message id or a message &#x60;eventId&#x60;
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @param attemptId The attempt&#39;s ID (required)
     * @return GetByAttemptRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public GetByAttemptRequestBuilder getByAttempt(String appId, String msgId, String attemptId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        if (attemptId == null) throw new IllegalArgumentException("\"attemptId\" is required but got null");
            

        return new GetByAttemptRequestBuilder(appId, msgId, attemptId);
    }
    private okhttp3.Call listAttemptedDestinationsCall(String appId, String msgId, Integer limit, String iterator, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg/{msg_id}/endpoint"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (iterator != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("iterator", iterator));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAttemptedDestinationsValidateBeforeCall(String appId, String msgId, Integer limit, String iterator, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling listAttemptedDestinations(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling listAttemptedDestinations(Async)");
        }

        return listAttemptedDestinationsCall(appId, msgId, limit, iterator, _callback);

    }


    private ApiResponse<ListResponseMessageEndpointOut> listAttemptedDestinationsWithHttpInfo(String appId, String msgId, Integer limit, String iterator) throws ApiException {
        okhttp3.Call localVarCall = listAttemptedDestinationsValidateBeforeCall(appId, msgId, limit, iterator, null);
        Type localVarReturnType = new TypeToken<ListResponseMessageEndpointOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAttemptedDestinationsAsync(String appId, String msgId, Integer limit, String iterator, final ApiCallback<ListResponseMessageEndpointOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = listAttemptedDestinationsValidateBeforeCall(appId, msgId, limit, iterator, _callback);
        Type localVarReturnType = new TypeToken<ListResponseMessageEndpointOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListAttemptedDestinationsRequestBuilder {
        private final String appId;
        private final String msgId;
        private Integer limit;
        private String iterator;

        private ListAttemptedDestinationsRequestBuilder(String appId, String msgId) {
            this.appId = appId;
            this.msgId = msgId;
        }

        /**
         * Set limit
         * @param limit Limit the number of returned items (optional)
         * @return ListAttemptedDestinationsRequestBuilder
         */
        public ListAttemptedDestinationsRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set iterator
         * @param iterator The iterator returned from a prior invocation (optional)
         * @return ListAttemptedDestinationsRequestBuilder
         */
        public ListAttemptedDestinationsRequestBuilder iterator(String iterator) {
            this.iterator = iterator;
            return this;
        }
        
        /**
         * Build call for listAttemptedDestinations
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listAttemptedDestinationsCall(appId, msgId, limit, iterator, _callback);
        }


        /**
         * Execute listAttemptedDestinations request
         * @return ListResponseMessageEndpointOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ListResponseMessageEndpointOut execute() throws ApiException {
            ApiResponse<ListResponseMessageEndpointOut> localVarResp = listAttemptedDestinationsWithHttpInfo(appId, msgId, limit, iterator);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listAttemptedDestinations request with HTTP info returned
         * @return ApiResponse&lt;ListResponseMessageEndpointOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListResponseMessageEndpointOut> executeWithHttpInfo() throws ApiException {
            return listAttemptedDestinationsWithHttpInfo(appId, msgId, limit, iterator);
        }

        /**
         * Execute listAttemptedDestinations request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListResponseMessageEndpointOut> _callback) throws ApiException {
            return listAttemptedDestinationsAsync(appId, msgId, limit, iterator, _callback);
        }
    }

    /**
     * List Attempted Destinations
     * List endpoints attempted by a given message. Additionally includes metadata about the latest message attempt. By default, endpoints are listed in ascending order by ID.
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @return ListAttemptedDestinationsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ListAttemptedDestinationsRequestBuilder listAttemptedDestinations(String appId, String msgId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        return new ListAttemptedDestinationsRequestBuilder(appId, msgId);
    }
    private okhttp3.Call listAttemptedMessagesCall(String appId, String endpointId, Integer limit, String iterator, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/endpoint/{endpoint_id}/msg"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "endpoint_id" + "}", localVarApiClient.escapeString(endpointId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (iterator != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("iterator", iterator));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (after != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("after", after));
        }

        if (withContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with_content", withContent));
        }

        if (eventTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "event_types", eventTypes));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAttemptedMessagesValidateBeforeCall(String appId, String endpointId, Integer limit, String iterator, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling listAttemptedMessages(Async)");
        }

        // verify the required parameter 'endpointId' is set
        if (endpointId == null) {
            throw new ApiException("Missing the required parameter 'endpointId' when calling listAttemptedMessages(Async)");
        }

        return listAttemptedMessagesCall(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes, _callback);

    }


    private ApiResponse<ListResponseEndpointMessageOut> listAttemptedMessagesWithHttpInfo(String appId, String endpointId, Integer limit, String iterator, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Set<String> eventTypes) throws ApiException {
        okhttp3.Call localVarCall = listAttemptedMessagesValidateBeforeCall(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes, null);
        Type localVarReturnType = new TypeToken<ListResponseEndpointMessageOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAttemptedMessagesAsync(String appId, String endpointId, Integer limit, String iterator, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Set<String> eventTypes, final ApiCallback<ListResponseEndpointMessageOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = listAttemptedMessagesValidateBeforeCall(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes, _callback);
        Type localVarReturnType = new TypeToken<ListResponseEndpointMessageOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListAttemptedMessagesRequestBuilder {
        private final String appId;
        private final String endpointId;
        private Integer limit;
        private String iterator;
        private String channel;
        private String tag;
        private MessageStatus status;
        private OffsetDateTime before;
        private OffsetDateTime after;
        private Boolean withContent;
        private Set<String> eventTypes;

        private ListAttemptedMessagesRequestBuilder(String appId, String endpointId) {
            this.appId = appId;
            this.endpointId = endpointId;
        }

        /**
         * Set limit
         * @param limit Limit the number of returned items (optional)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set iterator
         * @param iterator The iterator returned from a prior invocation (optional)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder iterator(String iterator) {
            this.iterator = iterator;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Filter response based on the channel (optional)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter response based on the message tags (optional)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set status
         * @param status Filter response based on the delivery status (optional)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder status(MessageStatus status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set before
         * @param before Only include items created before a certain date (optional)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder before(OffsetDateTime before) {
            this.before = before;
            return this;
        }
        
        /**
         * Set after
         * @param after Only include items created after a certain date (optional)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder after(OffsetDateTime after) {
            this.after = after;
            return this;
        }
        
        /**
         * Set withContent
         * @param withContent When &#x60;true&#x60; message payloads are included in the response (optional, default to true)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder withContent(Boolean withContent) {
            this.withContent = withContent;
            return this;
        }
        
        /**
         * Set eventTypes
         * @param eventTypes Filter response based on the event type (optional)
         * @return ListAttemptedMessagesRequestBuilder
         */
        public ListAttemptedMessagesRequestBuilder eventTypes(Set<String> eventTypes) {
            this.eventTypes = eventTypes;
            return this;
        }
        
        /**
         * Build call for listAttemptedMessages
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listAttemptedMessagesCall(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes, _callback);
        }


        /**
         * Execute listAttemptedMessages request
         * @return ListResponseEndpointMessageOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ListResponseEndpointMessageOut execute() throws ApiException {
            ApiResponse<ListResponseEndpointMessageOut> localVarResp = listAttemptedMessagesWithHttpInfo(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listAttemptedMessages request with HTTP info returned
         * @return ApiResponse&lt;ListResponseEndpointMessageOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListResponseEndpointMessageOut> executeWithHttpInfo() throws ApiException {
            return listAttemptedMessagesWithHttpInfo(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes);
        }

        /**
         * Execute listAttemptedMessages request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListResponseEndpointMessageOut> _callback) throws ApiException {
            return listAttemptedMessagesAsync(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes, _callback);
        }
    }

    /**
     * List Attempted Messages
     * List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The &#x60;before&#x60; parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days&#39; worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the &#x60;before&#x60; or &#x60;after&#x60; parameter as appropriate. 
     * @param appId The app&#39;s ID or UID (required)
     * @param endpointId The ep&#39;s ID or UID (required)
     * @return ListAttemptedMessagesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ListAttemptedMessagesRequestBuilder listAttemptedMessages(String appId, String endpointId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (endpointId == null) throw new IllegalArgumentException("\"endpointId\" is required but got null");
            if (endpointId != null && endpointId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for endpointId. Length must be greater than or equal to 1.");
            }

        return new ListAttemptedMessagesRequestBuilder(appId, endpointId);
    }
    private okhttp3.Call listByEndpointCall(String appId, String endpointId, Integer limit, String iterator, MessageStatus status, StatusCodeClass statusCodeClass, String channel, String tag, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Boolean withMsg, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/attempt/endpoint/{endpoint_id}"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "endpoint_id" + "}", localVarApiClient.escapeString(endpointId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (iterator != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("iterator", iterator));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (statusCodeClass != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status_code_class", statusCodeClass));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (after != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("after", after));
        }

        if (withContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with_content", withContent));
        }

        if (withMsg != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with_msg", withMsg));
        }

        if (eventTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "event_types", eventTypes));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listByEndpointValidateBeforeCall(String appId, String endpointId, Integer limit, String iterator, MessageStatus status, StatusCodeClass statusCodeClass, String channel, String tag, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Boolean withMsg, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling listByEndpoint(Async)");
        }

        // verify the required parameter 'endpointId' is set
        if (endpointId == null) {
            throw new ApiException("Missing the required parameter 'endpointId' when calling listByEndpoint(Async)");
        }

        return listByEndpointCall(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes, _callback);

    }


    private ApiResponse<ListResponseMessageAttemptOut> listByEndpointWithHttpInfo(String appId, String endpointId, Integer limit, String iterator, MessageStatus status, StatusCodeClass statusCodeClass, String channel, String tag, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Boolean withMsg, Set<String> eventTypes) throws ApiException {
        okhttp3.Call localVarCall = listByEndpointValidateBeforeCall(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes, null);
        Type localVarReturnType = new TypeToken<ListResponseMessageAttemptOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listByEndpointAsync(String appId, String endpointId, Integer limit, String iterator, MessageStatus status, StatusCodeClass statusCodeClass, String channel, String tag, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Boolean withMsg, Set<String> eventTypes, final ApiCallback<ListResponseMessageAttemptOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = listByEndpointValidateBeforeCall(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes, _callback);
        Type localVarReturnType = new TypeToken<ListResponseMessageAttemptOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListByEndpointRequestBuilder {
        private final String appId;
        private final String endpointId;
        private Integer limit;
        private String iterator;
        private MessageStatus status;
        private StatusCodeClass statusCodeClass;
        private String channel;
        private String tag;
        private OffsetDateTime before;
        private OffsetDateTime after;
        private Boolean withContent;
        private Boolean withMsg;
        private Set<String> eventTypes;

        private ListByEndpointRequestBuilder(String appId, String endpointId) {
            this.appId = appId;
            this.endpointId = endpointId;
        }

        /**
         * Set limit
         * @param limit Limit the number of returned items (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set iterator
         * @param iterator The iterator returned from a prior invocation (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder iterator(String iterator) {
            this.iterator = iterator;
            return this;
        }
        
        /**
         * Set status
         * @param status Filter response based on the delivery status (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder status(MessageStatus status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set statusCodeClass
         * @param statusCodeClass Filter response based on the HTTP status code (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder statusCodeClass(StatusCodeClass statusCodeClass) {
            this.statusCodeClass = statusCodeClass;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Filter response based on the channel (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter response based on the tag (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set before
         * @param before Only include items created before a certain date (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder before(OffsetDateTime before) {
            this.before = before;
            return this;
        }
        
        /**
         * Set after
         * @param after Only include items created after a certain date (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder after(OffsetDateTime after) {
            this.after = after;
            return this;
        }
        
        /**
         * Set withContent
         * @param withContent When &#x60;true&#x60; attempt content is included in the response (optional, default to true)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder withContent(Boolean withContent) {
            this.withContent = withContent;
            return this;
        }
        
        /**
         * Set withMsg
         * @param withMsg When &#x60;true&#x60;, the message information is included in the response (optional, default to false)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder withMsg(Boolean withMsg) {
            this.withMsg = withMsg;
            return this;
        }
        
        /**
         * Set eventTypes
         * @param eventTypes Filter response based on the event type (optional)
         * @return ListByEndpointRequestBuilder
         */
        public ListByEndpointRequestBuilder eventTypes(Set<String> eventTypes) {
            this.eventTypes = eventTypes;
            return this;
        }
        
        /**
         * Build call for listByEndpoint
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listByEndpointCall(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes, _callback);
        }


        /**
         * Execute listByEndpoint request
         * @return ListResponseMessageAttemptOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ListResponseMessageAttemptOut execute() throws ApiException {
            ApiResponse<ListResponseMessageAttemptOut> localVarResp = listByEndpointWithHttpInfo(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listByEndpoint request with HTTP info returned
         * @return ApiResponse&lt;ListResponseMessageAttemptOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListResponseMessageAttemptOut> executeWithHttpInfo() throws ApiException {
            return listByEndpointWithHttpInfo(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes);
        }

        /**
         * Execute listByEndpoint request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListResponseMessageAttemptOut> _callback) throws ApiException {
            return listByEndpointAsync(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes, _callback);
        }
    }

    /**
     * List Attempts By Endpoint
     * List attempts by endpoint id  Note that by default this endpoint is limited to retrieving 90 days&#39; worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the &#x60;before&#x60; or &#x60;after&#x60; parameter as appropriate. 
     * @param appId The app&#39;s ID or UID (required)
     * @param endpointId The ep&#39;s ID or UID (required)
     * @return ListByEndpointRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ListByEndpointRequestBuilder listByEndpoint(String appId, String endpointId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (endpointId == null) throw new IllegalArgumentException("\"endpointId\" is required but got null");
            if (endpointId != null && endpointId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for endpointId. Length must be greater than or equal to 1.");
            }

        return new ListByEndpointRequestBuilder(appId, endpointId);
    }
    private okhttp3.Call listByEndpointDeprecatedCall(String appId, String msgId, String endpointId, Integer limit, String iterator, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/attempt"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()))
            .replace("{" + "endpoint_id" + "}", localVarApiClient.escapeString(endpointId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (iterator != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("iterator", iterator));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (after != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("after", after));
        }

        if (eventTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "event_types", eventTypes));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call listByEndpointDeprecatedValidateBeforeCall(String appId, String msgId, String endpointId, Integer limit, String iterator, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling listByEndpointDeprecated(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling listByEndpointDeprecated(Async)");
        }

        // verify the required parameter 'endpointId' is set
        if (endpointId == null) {
            throw new ApiException("Missing the required parameter 'endpointId' when calling listByEndpointDeprecated(Async)");
        }

        return listByEndpointDeprecatedCall(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes, _callback);

    }


    private ApiResponse<ListResponseMessageAttemptEndpointOut> listByEndpointDeprecatedWithHttpInfo(String appId, String msgId, String endpointId, Integer limit, String iterator, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, Set<String> eventTypes) throws ApiException {
        okhttp3.Call localVarCall = listByEndpointDeprecatedValidateBeforeCall(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes, null);
        Type localVarReturnType = new TypeToken<ListResponseMessageAttemptEndpointOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listByEndpointDeprecatedAsync(String appId, String msgId, String endpointId, Integer limit, String iterator, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, Set<String> eventTypes, final ApiCallback<ListResponseMessageAttemptEndpointOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = listByEndpointDeprecatedValidateBeforeCall(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes, _callback);
        Type localVarReturnType = new TypeToken<ListResponseMessageAttemptEndpointOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListByEndpointDeprecatedRequestBuilder {
        private final String appId;
        private final String msgId;
        private final String endpointId;
        private Integer limit;
        private String iterator;
        private String channel;
        private String tag;
        private MessageStatus status;
        private OffsetDateTime before;
        private OffsetDateTime after;
        private Set<String> eventTypes;

        private ListByEndpointDeprecatedRequestBuilder(String appId, String msgId, String endpointId) {
            this.appId = appId;
            this.msgId = msgId;
            this.endpointId = endpointId;
        }

        /**
         * Set limit
         * @param limit Limit the number of returned items (optional)
         * @return ListByEndpointDeprecatedRequestBuilder
         */
        public ListByEndpointDeprecatedRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set iterator
         * @param iterator The iterator returned from a prior invocation (optional)
         * @return ListByEndpointDeprecatedRequestBuilder
         */
        public ListByEndpointDeprecatedRequestBuilder iterator(String iterator) {
            this.iterator = iterator;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Filter response based on the channel (optional)
         * @return ListByEndpointDeprecatedRequestBuilder
         */
        public ListByEndpointDeprecatedRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter response based on the tag (optional)
         * @return ListByEndpointDeprecatedRequestBuilder
         */
        public ListByEndpointDeprecatedRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set status
         * @param status Filter response based on the delivery status (optional)
         * @return ListByEndpointDeprecatedRequestBuilder
         */
        public ListByEndpointDeprecatedRequestBuilder status(MessageStatus status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set before
         * @param before Only include items created before a certain date (optional)
         * @return ListByEndpointDeprecatedRequestBuilder
         */
        public ListByEndpointDeprecatedRequestBuilder before(OffsetDateTime before) {
            this.before = before;
            return this;
        }
        
        /**
         * Set after
         * @param after Only include items created after a certain date (optional)
         * @return ListByEndpointDeprecatedRequestBuilder
         */
        public ListByEndpointDeprecatedRequestBuilder after(OffsetDateTime after) {
            this.after = after;
            return this;
        }
        
        /**
         * Set eventTypes
         * @param eventTypes Filter response based on the event type (optional)
         * @return ListByEndpointDeprecatedRequestBuilder
         */
        public ListByEndpointDeprecatedRequestBuilder eventTypes(Set<String> eventTypes) {
            this.eventTypes = eventTypes;
            return this;
        }
        
        /**
         * Build call for listByEndpointDeprecated
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listByEndpointDeprecatedCall(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes, _callback);
        }


        /**
         * Execute listByEndpointDeprecated request
         * @return ListResponseMessageAttemptEndpointOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ListResponseMessageAttemptEndpointOut execute() throws ApiException {
            ApiResponse<ListResponseMessageAttemptEndpointOut> localVarResp = listByEndpointDeprecatedWithHttpInfo(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listByEndpointDeprecated request with HTTP info returned
         * @return ApiResponse&lt;ListResponseMessageAttemptEndpointOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<ListResponseMessageAttemptEndpointOut> executeWithHttpInfo() throws ApiException {
            return listByEndpointDeprecatedWithHttpInfo(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes);
        }

        /**
         * Execute listByEndpointDeprecated request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<ListResponseMessageAttemptEndpointOut> _callback) throws ApiException {
            return listByEndpointDeprecatedAsync(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes, _callback);
        }
    }

    /**
     * List Attempts For Endpoint
     * DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The &#x60;before&#x60; parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days&#39; worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the &#x60;before&#x60; or &#x60;after&#x60; parameter as appropriate. 
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @param endpointId The ep&#39;s ID or UID (required)
     * @return ListByEndpointDeprecatedRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public ListByEndpointDeprecatedRequestBuilder listByEndpointDeprecated(String appId, String msgId, String endpointId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        if (endpointId == null) throw new IllegalArgumentException("\"endpointId\" is required but got null");
            if (endpointId != null && endpointId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for endpointId. Length must be greater than or equal to 1.");
            }

        return new ListByEndpointDeprecatedRequestBuilder(appId, msgId, endpointId);
    }
    private okhttp3.Call listByMsgCall(String appId, String msgId, Integer limit, String iterator, MessageStatus status, StatusCodeClass statusCodeClass, String channel, String tag, String endpointId, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/attempt/msg/{msg_id}"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (iterator != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("iterator", iterator));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (statusCodeClass != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status_code_class", statusCodeClass));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (endpointId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endpoint_id", endpointId));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (after != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("after", after));
        }

        if (withContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("with_content", withContent));
        }

        if (eventTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "event_types", eventTypes));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listByMsgValidateBeforeCall(String appId, String msgId, Integer limit, String iterator, MessageStatus status, StatusCodeClass statusCodeClass, String channel, String tag, String endpointId, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling listByMsg(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling listByMsg(Async)");
        }

        return listByMsgCall(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes, _callback);

    }


    private ApiResponse<ListResponseMessageAttemptOut> listByMsgWithHttpInfo(String appId, String msgId, Integer limit, String iterator, MessageStatus status, StatusCodeClass statusCodeClass, String channel, String tag, String endpointId, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Set<String> eventTypes) throws ApiException {
        okhttp3.Call localVarCall = listByMsgValidateBeforeCall(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes, null);
        Type localVarReturnType = new TypeToken<ListResponseMessageAttemptOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listByMsgAsync(String appId, String msgId, Integer limit, String iterator, MessageStatus status, StatusCodeClass statusCodeClass, String channel, String tag, String endpointId, OffsetDateTime before, OffsetDateTime after, Boolean withContent, Set<String> eventTypes, final ApiCallback<ListResponseMessageAttemptOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = listByMsgValidateBeforeCall(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes, _callback);
        Type localVarReturnType = new TypeToken<ListResponseMessageAttemptOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListByMsgRequestBuilder {
        private final String appId;
        private final String msgId;
        private Integer limit;
        private String iterator;
        private MessageStatus status;
        private StatusCodeClass statusCodeClass;
        private String channel;
        private String tag;
        private String endpointId;
        private OffsetDateTime before;
        private OffsetDateTime after;
        private Boolean withContent;
        private Set<String> eventTypes;

        private ListByMsgRequestBuilder(String appId, String msgId) {
            this.appId = appId;
            this.msgId = msgId;
        }

        /**
         * Set limit
         * @param limit Limit the number of returned items (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set iterator
         * @param iterator The iterator returned from a prior invocation (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder iterator(String iterator) {
            this.iterator = iterator;
            return this;
        }
        
        /**
         * Set status
         * @param status Filter response based on the delivery status (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder status(MessageStatus status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set statusCodeClass
         * @param statusCodeClass Filter response based on the HTTP status code (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder statusCodeClass(StatusCodeClass statusCodeClass) {
            this.statusCodeClass = statusCodeClass;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Filter response based on the channel (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter response based on the tag (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set endpointId
         * @param endpointId Filter the attempts based on the attempted endpoint (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder endpointId(String endpointId) {
            this.endpointId = endpointId;
            return this;
        }
        
        /**
         * Set before
         * @param before Only include items created before a certain date (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder before(OffsetDateTime before) {
            this.before = before;
            return this;
        }
        
        /**
         * Set after
         * @param after Only include items created after a certain date (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder after(OffsetDateTime after) {
            this.after = after;
            return this;
        }
        
        /**
         * Set withContent
         * @param withContent When &#x60;true&#x60; attempt content is included in the response (optional, default to true)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder withContent(Boolean withContent) {
            this.withContent = withContent;
            return this;
        }
        
        /**
         * Set eventTypes
         * @param eventTypes Filter response based on the event type (optional)
         * @return ListByMsgRequestBuilder
         */
        public ListByMsgRequestBuilder eventTypes(Set<String> eventTypes) {
            this.eventTypes = eventTypes;
            return this;
        }
        
        /**
         * Build call for listByMsg
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listByMsgCall(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes, _callback);
        }


        /**
         * Execute listByMsg request
         * @return ListResponseMessageAttemptOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ListResponseMessageAttemptOut execute() throws ApiException {
            ApiResponse<ListResponseMessageAttemptOut> localVarResp = listByMsgWithHttpInfo(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listByMsg request with HTTP info returned
         * @return ApiResponse&lt;ListResponseMessageAttemptOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ListResponseMessageAttemptOut> executeWithHttpInfo() throws ApiException {
            return listByMsgWithHttpInfo(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes);
        }

        /**
         * Execute listByMsg request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ListResponseMessageAttemptOut> _callback) throws ApiException {
            return listByMsgAsync(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes, _callback);
        }
    }

    /**
     * List Attempts By Msg
     * List attempts by message id  Note that by default this endpoint is limited to retrieving 90 days&#39; worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the &#x60;before&#x60; or &#x60;after&#x60; parameter as appropriate. 
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @return ListByMsgRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ListByMsgRequestBuilder listByMsg(String appId, String msgId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        return new ListByMsgRequestBuilder(appId, msgId);
    }
    private okhttp3.Call listByMsgAttemptCall(String appId, String msgId, Integer limit, String iterator, String endpointId, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, StatusCodeClass statusCodeClass, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg/{msg_id}/attempt"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (iterator != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("iterator", iterator));
        }

        if (endpointId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endpoint_id", endpointId));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (after != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("after", after));
        }

        if (statusCodeClass != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status_code_class", statusCodeClass));
        }

        if (eventTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "event_types", eventTypes));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call listByMsgAttemptValidateBeforeCall(String appId, String msgId, Integer limit, String iterator, String endpointId, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, StatusCodeClass statusCodeClass, Set<String> eventTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling listByMsgAttempt(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling listByMsgAttempt(Async)");
        }

        return listByMsgAttemptCall(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes, _callback);

    }


    private ApiResponse<ListResponseMessageAttemptOut> listByMsgAttemptWithHttpInfo(String appId, String msgId, Integer limit, String iterator, String endpointId, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, StatusCodeClass statusCodeClass, Set<String> eventTypes) throws ApiException {
        okhttp3.Call localVarCall = listByMsgAttemptValidateBeforeCall(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes, null);
        Type localVarReturnType = new TypeToken<ListResponseMessageAttemptOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listByMsgAttemptAsync(String appId, String msgId, Integer limit, String iterator, String endpointId, String channel, String tag, MessageStatus status, OffsetDateTime before, OffsetDateTime after, StatusCodeClass statusCodeClass, Set<String> eventTypes, final ApiCallback<ListResponseMessageAttemptOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = listByMsgAttemptValidateBeforeCall(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes, _callback);
        Type localVarReturnType = new TypeToken<ListResponseMessageAttemptOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListByMsgAttemptRequestBuilder {
        private final String appId;
        private final String msgId;
        private Integer limit;
        private String iterator;
        private String endpointId;
        private String channel;
        private String tag;
        private MessageStatus status;
        private OffsetDateTime before;
        private OffsetDateTime after;
        private StatusCodeClass statusCodeClass;
        private Set<String> eventTypes;

        private ListByMsgAttemptRequestBuilder(String appId, String msgId) {
            this.appId = appId;
            this.msgId = msgId;
        }

        /**
         * Set limit
         * @param limit Limit the number of returned items (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set iterator
         * @param iterator The iterator returned from a prior invocation (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder iterator(String iterator) {
            this.iterator = iterator;
            return this;
        }
        
        /**
         * Set endpointId
         * @param endpointId Filter the attempts based on the attempted endpoint (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder endpointId(String endpointId) {
            this.endpointId = endpointId;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Filter response based on the channel (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set tag
         * @param tag Filter response based on the tag (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder tag(String tag) {
            this.tag = tag;
            return this;
        }
        
        /**
         * Set status
         * @param status Filter response based on the delivery status (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder status(MessageStatus status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set before
         * @param before Only include items created before a certain date (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder before(OffsetDateTime before) {
            this.before = before;
            return this;
        }
        
        /**
         * Set after
         * @param after Only include items created after a certain date (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder after(OffsetDateTime after) {
            this.after = after;
            return this;
        }
        
        /**
         * Set statusCodeClass
         * @param statusCodeClass Filter response based on the HTTP status code (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder statusCodeClass(StatusCodeClass statusCodeClass) {
            this.statusCodeClass = statusCodeClass;
            return this;
        }
        
        /**
         * Set eventTypes
         * @param eventTypes Filter response based on the event type (optional)
         * @return ListByMsgAttemptRequestBuilder
         */
        public ListByMsgAttemptRequestBuilder eventTypes(Set<String> eventTypes) {
            this.eventTypes = eventTypes;
            return this;
        }
        
        /**
         * Build call for listByMsgAttempt
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listByMsgAttemptCall(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes, _callback);
        }


        /**
         * Execute listByMsgAttempt request
         * @return ListResponseMessageAttemptOut
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ListResponseMessageAttemptOut execute() throws ApiException {
            ApiResponse<ListResponseMessageAttemptOut> localVarResp = listByMsgAttemptWithHttpInfo(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listByMsgAttempt request with HTTP info returned
         * @return ApiResponse&lt;ListResponseMessageAttemptOut&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<ListResponseMessageAttemptOut> executeWithHttpInfo() throws ApiException {
            return listByMsgAttemptWithHttpInfo(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes);
        }

        /**
         * Execute listByMsgAttempt request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<ListResponseMessageAttemptOut> _callback) throws ApiException {
            return listByMsgAttemptAsync(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes, _callback);
        }
    }

    /**
     * List Attempts
     * Deprecated: Please use \&quot;List Attempts by Endpoint\&quot; and \&quot;List Attempts by Msg\&quot; instead.  Note that by default this endpoint is limited to retrieving 90 days&#39; worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the &#x60;before&#x60; or &#x60;after&#x60; parameter as appropriate.  &#x60;msg_id&#x60;: Use a message id or a message &#x60;eventId&#x60;
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @return ListByMsgAttemptRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public ListByMsgAttemptRequestBuilder listByMsgAttempt(String appId, String msgId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        return new ListByMsgAttemptRequestBuilder(appId, msgId);
    }
    private okhttp3.Call resendWebhookCall(String appId, String msgId, String endpointId, String idempotencyKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/resend"
            .replace("{" + "app_id" + "}", localVarApiClient.escapeString(appId.toString()))
            .replace("{" + "msg_id" + "}", localVarApiClient.escapeString(msgId.toString()))
            .replace("{" + "endpoint_id" + "}", localVarApiClient.escapeString(endpointId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (idempotencyKey != null) {
            localVarHeaderParams.put("idempotency-key", localVarApiClient.parameterToString(idempotencyKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call resendWebhookValidateBeforeCall(String appId, String msgId, String endpointId, String idempotencyKey, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling resendWebhook(Async)");
        }

        // verify the required parameter 'msgId' is set
        if (msgId == null) {
            throw new ApiException("Missing the required parameter 'msgId' when calling resendWebhook(Async)");
        }

        // verify the required parameter 'endpointId' is set
        if (endpointId == null) {
            throw new ApiException("Missing the required parameter 'endpointId' when calling resendWebhook(Async)");
        }

        return resendWebhookCall(appId, msgId, endpointId, idempotencyKey, _callback);

    }


    private ApiResponse<Void> resendWebhookWithHttpInfo(String appId, String msgId, String endpointId, String idempotencyKey) throws ApiException {
        okhttp3.Call localVarCall = resendWebhookValidateBeforeCall(appId, msgId, endpointId, idempotencyKey, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call resendWebhookAsync(String appId, String msgId, String endpointId, String idempotencyKey, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = resendWebhookValidateBeforeCall(appId, msgId, endpointId, idempotencyKey, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class ResendWebhookRequestBuilder {
        private final String appId;
        private final String msgId;
        private final String endpointId;
        private String idempotencyKey;

        private ResendWebhookRequestBuilder(String appId, String msgId, String endpointId) {
            this.appId = appId;
            this.msgId = msgId;
            this.endpointId = endpointId;
        }

        /**
         * Set idempotencyKey
         * @param idempotencyKey The request&#39;s idempotency key (optional)
         * @return ResendWebhookRequestBuilder
         */
        public ResendWebhookRequestBuilder idempotencyKey(String idempotencyKey) {
            this.idempotencyKey = idempotencyKey;
            return this;
        }
        
        /**
         * Build call for resendWebhook
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return resendWebhookCall(appId, msgId, endpointId, idempotencyKey, _callback);
        }


        /**
         * Execute resendWebhook request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            resendWebhookWithHttpInfo(appId, msgId, endpointId, idempotencyKey);
        }

        /**
         * Execute resendWebhook request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return resendWebhookWithHttpInfo(appId, msgId, endpointId, idempotencyKey);
        }

        /**
         * Execute resendWebhook request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return resendWebhookAsync(appId, msgId, endpointId, idempotencyKey, _callback);
        }
    }

    /**
     * Resend Webhook
     * Resend a message to the specified endpoint.
     * @param appId The app&#39;s ID or UID (required)
     * @param msgId The msg&#39;s ID or UID (required)
     * @param endpointId The ep&#39;s ID or UID (required)
     * @return ResendWebhookRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> no content </td><td>  -  </td></tr>
     </table>
     */
    public ResendWebhookRequestBuilder resendWebhook(String appId, String msgId, String endpointId) throws IllegalArgumentException {
        if (appId == null) throw new IllegalArgumentException("\"appId\" is required but got null");
            if (appId != null && appId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for appId. Length must be greater than or equal to 1.");
            }

        if (msgId == null) throw new IllegalArgumentException("\"msgId\" is required but got null");
            if (msgId != null && msgId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for msgId. Length must be greater than or equal to 1.");
            }

        if (endpointId == null) throw new IllegalArgumentException("\"endpointId\" is required but got null");
            if (endpointId != null && endpointId.length() < 1) {
              throw new IllegalArgumentException("Invalid value for endpointId. Length must be greater than or equal to 1.");
            }

        return new ResendWebhookRequestBuilder(appId, msgId, endpointId);
    }
}
